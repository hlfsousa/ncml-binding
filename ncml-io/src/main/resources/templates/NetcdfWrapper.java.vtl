package ${group.packageName};

#if ($customContent.imports)
${customContent.imports}
#else
// imports >>
import hsousa.ncml.io.wrapper.NetcdfWrapper;

import java.io.IOException;
import java.util.*;
import ucar.ma2.Array;
import ucar.nc2.Group;
import ucar.nc2.Variable;
// << imports
#end

public class ${group.camelCase($group.name)}Wrapper extends NetcdfWrapper implements ${group.camelCase($group.name)} {
#macro(findType $type)
  #set($unsigned = false)
  #if($type == "string" || $type == "String")
    #set($typeName = "String")
  #elseif($type == "byte" || $type == "ubyte")
    #set($typeName = "Byte")
    #set($unsigned = $type.charAt(0) == 'u')
  #elseif($type == "char")
    #set($typeName = "Character")
  #elseif($type == "short" || $type == "ushort")
    #set($typeName = "Short")
    #set($unsigned = $type.charAt(0) == 'u')
  #elseif($type == "int" || $type == "uint")
    #set($typeName = "Integer")
    #set($unsigned = $type.charAt(0) == 'u')
  #elseif($type == "long" || $type == "ulong")
    #set($typeName = "Long")
    #set($unsigned = $type.charAt(0) == 'u')
  #elseif($type == "float")
    #set($typeName = "Float")
  #elseif($type == "double")
    #set($typeName = "Double")
  #elseif($type == "Structure")
    #set($typeName = "Object") // TODO locate type
  #elseif($type == "Sequence")
    #set($typeName = "") // TODO Sequence
  #elseif($type == "opaque")
    #set($typeName = "Object") // TODO locate type
  #elseif($type == "enum1")
    #set($typeName = "") // TODO locate enumTypedef
  #elseif($type == "enum2")
    #set($typeName = "") // TODO locate enumTypedef
  #elseif($type == "enum4")
    #set($typeName = "") // TODO locate enumTypedef
  #end
#end
#macro(declareAttribute $attributeWrapper $netcdfObject $indent) ## TODO set indentation
  #set($property = ${attributeWrapper.camelCase($attributeWrapper.name)})
  #set($localVar = ${attributeWrapper.dromedaryCase($attributeWrapper.name)})
  #findType(${attributeWrapper.attribute.type})
${indent}    @Override
${indent}    public ${typeName} get${property}() {
${indent}        return Optional.ofNullable(${netcdfObject}.findAttribute("${attributeWrapper.attribute.name}"))
  #if($typeName == "String")
${indent}                .map(${localVar} -> ${localVar}.getStringValue())
  #else
${indent}                .map(${localVar} -> (${typeName})${localVar}.getNumericValue())
  #end
${indent}                .orElse(null);
${indent}    }

${indent}    @Override
${indent}    public void set${property}(${typeName} ${localVar}) {
${indent}        throw new UnsupportedOperationException();
${indent}    }

#end
#macro(declareArrayVariable $varWrapper)
  #set($property = ${varWrapper.camelCase($varWrapper.name)})
  #set($typeName = $property + "Wrapper")
  #set($intfName = $property + "Variable")
    private class ${typeName} implements ${intfName}<Array> {

        private final Variable variable;
        private Array value;
        
        public ${typeName}(Variable variable) {
            this.variable = variable;
        }

        @Override
        public Array getValue() {
            if (value == null) {
                value = getNumericArray("${varWrapper.variable.name}");
            }
            return value;
        }
        
        @Override
        public void setValue(Array value) {
            throw new UnsupportedOperationException();
        }

  #foreach($attributeWrapper in ${varWrapper.attributes})
    #declareAttribute($attributeWrapper, "variable", "    ")
  #end
    }

#end

#foreach($varWrapper in $group.variables)
  #if(!${varWrapper.attributes.empty})
    #if(${varWrapper.dimensions.empty})
    // incomplete template: declare scalar variable ${varWrapper.variable.name}, which contains attributes
    #else
      #declareArrayVariable($varWrapper)
    #end

  #end
#end

    public ${group.camelCase($group.name)}Wrapper(Group group) {
        super(group);
    }

#if(!${group.variables.empty})
    private Map<String, Object> variableCache = new HashMap<String,Object>();
    
    // additionalFields >>
$!{customContent.additionalFields}
    // << additionalFields

  #foreach($varWrapper in $group.variables)
    #set($property = ${varWrapper.camelCase($varWrapper.name)})
    #if(${varWrapper.attributes.empty})
    // no attributes array
    public Array get${property}() {
        return (Array) variableCache.computeIfAbsent("${varWrapper.variable.name}",
                varName -> Optional.ofNullable(group.findVariable(varName))
                        .map(var -> {
                            try {
                                return var.read();
                            } catch (IOException e) {
                                throw new IllegalStateException(e);
                            }
                        })
                        .orElse(null));
    }

    public void set${property}(Array ${varWrapper.dromedaryCase($varWrapper.name)}) {
        throw new UnsupportedOperationException();
    }

    #else
      #if(${varWrapper.dimensions.empty})
    // scalar variable $varWrapper.variable.name
        
      #else
        #set($typeName = $property + "Wrapper")
        #set($intfName = $property + "Variable")
    @SuppressWarnings("unchecked")
    public ${intfName}<Array> get${property}() {
        return (${intfName}<Array>) variableCache.computeIfAbsent("${varWrapper.variable.name}",
                varName -> Optional.ofNullable(group.findVariable(varName))
                        .map(${typeName}::new)
                        .orElse(null));
    }

    public void set${property}(${intfName}<Array> ${varWrapper.dromedaryCase($varWrapper.name)}) {
        throw new UnsupportedOperationException();
    }

      #end
    #end
  #end
#end
#if(!${group.attributes.empty})
  #foreach($attributeWrapper in ${group.attributes})
    #declareAttribute($attributeWrapper, "group", "")
  #end
#end

    // additionalMethods >>
$!{customContent.additionalMethods}
    // << additionalMethods

}
